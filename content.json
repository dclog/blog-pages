{"meta":{"title":"DcBlog","subtitle":"","description":"邓聪个人博客","author":"DeCo","url":"https://blog.dclog.cn","root":"/"},"posts":[{"tags":[{"name":"oracle","slug":"oracle","permalink":"https://blog.dclog.cn/tags/oracle/"}],"title":"Oracle常用内置函数","date":"2019/11/11","text":"","permalink":"https://blog.dclog.cn/d6284ddb.html","photos":["/d6284ddb/1.png"]},{"tags":[{"name":"dubbo","slug":"dubbo","permalink":"https://blog.dclog.cn/tags/dubbo/"},{"name":"异常","slug":"异常","permalink":"https://blog.dclog.cn/tags/%E5%BC%82%E5%B8%B8/"}],"title":"dubbo处理自定义异常问题","date":"2019/05/17","text":"在使用dubb的时候发现了一个问题，在api包中自定义了异常，在服务提供端抛出，在服务消费端竟然无法捕获 dubbo-api import demo.dubbo.spring.boot.api.exception.ApiException; import demo.dubbo.spring.boot.api.exception.ApiRuntimeException; public interface EchoService &#123; String echo(String message); String echoExp(String message) throws ApiException; String echoRuntimeExp(String message); &#125; public class ApiException extends Exception &#123; private static final long serialVersionUID = 7811529833876460537L; &#125; public class ApiRuntimeException extends RuntimeException &#123; private static final long serialVersionUID = -5973522858593078694L; &#125; dubbo-provider @Service( version = \"$&#123;echo.service.version&#125;\", application = \"$&#123;dubbo.application.id&#125;\", protocol = \"$&#123;dubbo.protocol.id&#125;\", registry = \"$&#123;dubbo.registry.id&#125;\" ) public class DefaultEchoService implements EchoService &#123; @Override public String echo(String message) &#123; String response = \"Echo : \" + message; System.out.println(response); return response; &#125; @Override public String echoExp(String message) throws ApiException &#123; String response = \"Echo : \" + message; if (true) &#123; throw new ApiException(); &#125; return response; &#125; @Override public String echoRuntimeExp(String message) &#123; String response = \"Echo : \" + message; if (true) &#123; throw new ApiRuntimeException(); &#125; return response; &#125; &#125; dubbo-consumer @Reference( version = \"$&#123;echo.service.version&#125;\", application = \"$&#123;dubbo.application.id&#125;\", url = \"dubbo://localhost:12345\" ) private EchoService echoService; @GetMapping(\"/exp\") public String echoExp(@RequestParam String message) throws ApiException &#123; try &#123; return echoService.echoExp(message); &#125; catch (ApiException e) &#123; System.out.println(\"ApiException\"); &#125; catch (RuntimeException e) &#123; System.out.println(\"RuntimeException\"); &#125; catch (Exception e) &#123; System.out.println(\"Exception\"); &#125; return \"errormsg\"; &#125; @GetMapping(\"/expRun\") public String echoExpRun(@RequestParam String message) &#123; try &#123; return echoService.echoRuntimeExp(message); &#125; catch (ApiRuntimeException e) &#123; System.out.println(\"ApiRuntimeException\"); &#125; catch (RuntimeException e) &#123; System.out.println(\"RuntimeException\"); &#125; catch (Exception e) &#123; System.out.println(\"Exception\"); &#125; return \"errormsg\"; &#125; 控制台打印 RuntimeException RuntimeException 自定义异常没有捕获到。。RuntimeException倒是捕获成功了。。 查阅了一下资料以后是因为dubbo对异常进行了处理,如果Dubbo的暴露抛出异常（Throwable），则会被暴露方的ExceptionFilter拦截到，执行以下invoke方法: /** * ExceptionInvokerFilter * &lt;p&gt; * Functions: * &lt;ol&gt; * &lt;li&gt;unexpected exception will be logged in ERROR level on provider side. Unexpected exception are unchecked * exception not declared on the interface&lt;/li&gt; * &lt;li&gt;Wrap the exception not introduced in API package into RuntimeException. Framework will serialize the outer exception but stringnize its cause in order to avoid of possible serialization problem on client side&lt;/li&gt; * &lt;/ol&gt; * &lt;p&gt; * 功能： * &lt;ol&gt; * &lt;li&gt;不期望的异常打ERROR日志（Provider端）&lt;br&gt; * 不期望的日志即是，没有的接口上声明的Unchecked异常。 * &lt;li&gt;异常不在API包中，则Wrap一层RuntimeException。&lt;br&gt; * RPC对于第一层异常会直接序列化传输(Cause异常会String化)，避免异常在Client出不能反序列化问题。 */ @Activate(group = Constants.PROVIDER) public class ExceptionFilter implements Filter &#123; private final Logger logger; public ExceptionFilter() &#123; this(LoggerFactory.getLogger(ExceptionFilter.class)); &#125; public ExceptionFilter(Logger logger) &#123; this.logger = logger; &#125; @Override public Result invoke(Invoker&lt;?&gt; invoker, Invocation invocation) throws RpcException &#123; try &#123; Result result = invoker.invoke(invocation); if (result.hasException() &amp;&amp; GenericService.class != invoker.getInterface()) &#123; try &#123; Throwable exception = result.getException(); // directly throw if it's checked exception // 如果是checked异常，直接抛出 if (!(exception instanceof RuntimeException) &amp;&amp; (exception instanceof Exception)) &#123; return result; &#125; // directly throw if the exception appears in the signature // 在方法签名上有声明，直接抛出 try &#123; Method method = invoker.getInterface().getMethod(invocation.getMethodName(), invocation.getParameterTypes()); Class&lt;?&gt;[] exceptionClassses = method.getExceptionTypes(); for (Class&lt;?&gt; exceptionClass : exceptionClassses) &#123; if (exception.getClass().equals(exceptionClass)) &#123; return result; &#125; &#125; &#125; catch (NoSuchMethodException e) &#123; return result; &#125; // 未在方法签名上定义的异常，在服务器端打印ERROR日志 // for the exception not found in method's signature, print ERROR message in server's log. logger.error(\"Got unchecked and undeclared exception which called by \" + RpcContext.getContext().getRemoteHost() + \". service: \" + invoker.getInterface().getName() + \", method: \" + invocation.getMethodName() + \", exception: \" + exception.getClass().getName() + \": \" + exception.getMessage(), exception); // 异常类和接口类在同一jar包里，直接抛出 // directly throw if exception class and interface class are in the same jar file. String serviceFile = ReflectUtils.getCodeBase(invoker.getInterface()); String exceptionFile = ReflectUtils.getCodeBase(exception.getClass()); if (serviceFile == null || exceptionFile == null || serviceFile.equals(exceptionFile)) &#123; return result; &#125; // 是JDK自带的异常，直接抛出 // directly throw if it's JDK exception String className = exception.getClass().getName(); if (className.startsWith(\"java.\") || className.startsWith(\"javax.\")) &#123; return result; &#125; // 是Dubbo本身的异常，直接抛出 // directly throw if it's dubbo exception if (exception instanceof RpcException) &#123; return result; &#125; // 否则，包装成RuntimeException抛给客户端 // otherwise, wrap with RuntimeException and throw back to the client return new RpcResult(new RuntimeException(StringUtils.toString(exception))); &#125; catch (Throwable e) &#123; logger.warn(\"Fail to ExceptionFilter when called by \" + RpcContext.getContext().getRemoteHost() + \". service: \" + invoker.getInterface().getName() + \", method: \" + invocation.getMethodName() + \", exception: \" + e.getClass().getName() + \": \" + e.getMessage(), e); return result; &#125; &#125; return result; &#125; catch (RuntimeException e) &#123; logger.error(\"Got unchecked and undeclared exception which called by \" + RpcContext.getContext().getRemoteHost() + \". service: \" + invoker.getInterface().getName() + \", method: \" + invocation.getMethodName() + \", exception: \" + e.getClass().getName() + \": \" + e.getMessage(), e); throw e; &#125; &#125; &#125; 调试发现在生产者端是返回的是自定义的异常 消费端catch到的是动态代理异常UndeclaredThrowableException","permalink":"https://blog.dclog.cn/e80a56ae.html","photos":[]},{"tags":[{"name":"Groovy","slug":"Groovy","permalink":"https://blog.dclog.cn/tags/Groovy/"},{"name":"脚本","slug":"脚本","permalink":"https://blog.dclog.cn/tags/%E8%84%9A%E6%9C%AC/"}],"title":"Groovy使用","date":"2019/05/09","text":"pom依赖 &lt;dependency&gt; &lt;groupId&gt;org.codehaus.groovy&lt;/groupId&gt; &lt;artifactId&gt;groovy-all&lt;/artifactId&gt; &lt;version&gt;2.4.11&lt;/version&gt; &lt;/dependency&gt; 测试代码 import groovy.json.JsonSlurper; import groovy.lang.Binding; import groovy.lang.GroovyShell; import org.junit.Test; /** * @author DC * @date 2019-05-09 */ public class GroovyTest &#123; private static final String JSON_STR = \"&#123;\\n\" + \" \\\"evalMatches\\\": [\\n\" + \" &#123;\\n\" + \" \\\"value\\\": 15,\\n\" + \" \\\"metric\\\": \\\"Count\\\",\\n\" + \" \\\"tags\\\": &#123;&#125;\\n\" + \" &#125;\\n\" + \" ],\\n\" + \" \\\"state\\\": \\\"alerting\\\"\\n\" + \"&#125;\"; private static final String SCRIPT = \"body.evalMatches.each&#123;message += \\\"指标:\\\" + it.metric + \\\",值:\\\" + it.value + \\\"\\\\n\\\" &#125;\"; private static final String SCRIPT_RETURN = \"body.evalMatches.each&#123;message += \\\"指标:\\\" + it.metric + \\\",值:\\\" + it.value + \\\"\\\\n\\\" &#125;; return message\"; @Test public void groovyTest() &#123; // 脚本变量绑定对象 Binding binding = new Binding(); // groovy JSON解析器 JsonSlurper jsonSlurper = new JsonSlurper(); // 将json字符串转换成groovy的json对象 Object groovyJsonObject = jsonSlurper.parseText(JSON_STR); // 设置groovy变量 binding.setVariable(\"body\", groovyJsonObject); binding.setVariable(\"message\", \"\"); // Groovy脚本执行器 GroovyShell shell = new GroovyShell(binding); // 执行脚本（） shell.evaluate(SCRIPT); // 获取变量值 String message = String.valueOf(binding.getVariable(\"message\")); System.out.println(message); &#125; @Test public void groovyTest2() &#123; Binding binding = new Binding(); JsonSlurper jsonSlurper = new JsonSlurper(); Object groovyJsonObject = jsonSlurper.parseText(JSON_STR); binding.setVariable(\"body\", groovyJsonObject); binding.setVariable(\"message\", \"\"); // 脚本有返回值可以接受 GroovyShell shell = new GroovyShell(binding); String message = (String) shell.evaluate(SCRIPT_RETURN); System.out.println(message); &#125; &#125; 输出 指标:Count,值:15","permalink":"https://blog.dclog.cn/68870659.html","photos":[]},{"tags":[{"name":"脚本","slug":"脚本","permalink":"https://blog.dclog.cn/tags/%E8%84%9A%E6%9C%AC/"},{"name":"janino","slug":"janino","permalink":"https://blog.dclog.cn/tags/janino/"}],"title":"janino使用","date":"2019/05/09","text":"pom依赖 &lt;dependency&gt; &lt;groupId&gt;org.codehaus.janino&lt;/groupId&gt; &lt;artifactId&gt;janino&lt;/artifactId&gt; &lt;version&gt;3.0.12&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.44&lt;/version&gt; &lt;/dependency&gt; 测试代码 import com.alibaba.fastjson.JSON; import com.alibaba.fastjson.JSONObject; import org.codehaus.commons.compiler.CompileException; import org.codehaus.janino.ScriptEvaluator; import org.junit.Test; import java.lang.reflect.InvocationTargetException; import java.util.ArrayList; import java.util.List; public class JaninoTest &#123; private static final String JSON_STR = \"&#123;\\\"evalMatches\\\":[&#123;\\\"value\\\":1501,\\\"metric\\\":\\\"billItemQry ERROR\\\",\" + \"\\\"tags\\\":&#123;\\\"level.keyword\\\":\\\"ERROR\\\",\\\"name.keyword\\\":\\\"billItemQry\\\"&#125;&#125;,&#123;\\\"value\\\":1501,\" + \"\\\"metric\\\":\\\"EXTHIRDQRY ERROR\\\",\\\"tags\\\":&#123;\\\"level.keyword\\\":\\\"ERROR\\\",\\\"name.keyword\\\":\\\"EXTHIRDQRY\\\"&#125;&#125;,\" + \"&#123;\\\"value\\\":1501,\\\"metric\\\":\\\"qryIsOnWay ERROR\\\",\\\"tags\\\":&#123;\\\"level.keyword\\\":\\\"ERROR\\\",\\\"name\" + \".keyword\\\":\\\"qryIsOnWay\\\"&#125;&#125;,&#123;\\\"value\\\":1501,\\\"metric\\\":\\\"autoTestWXKFNew ERROR\\\",\\\"tags\\\":&#123;\\\"level\" + \".keyword\\\":\\\"ERROR\\\",\\\"name.keyword\\\":\\\"autoTestWXKFNew\\\"&#125;&#125;,&#123;\\\"value\\\":1501,\" + \"\\\"metric\\\":\\\"checkLineQuality ERROR\\\",\\\"tags\\\":&#123;\\\"level.keyword\\\":\\\"ERROR\\\",\\\"name\" + \".keyword\\\":\\\"checkLineQuality\\\"&#125;&#125;,&#123;\\\"value\\\":1501,\\\"metric\\\":\\\"ERROR checkRateStateNew\\\",\" + \"\\\"tags\\\":&#123;\\\"level.keyword\\\":\\\"ERROR\\\",\\\"name.keyword\\\":\\\"checkRateStateNew\\\"&#125;&#125;,&#123;\\\"value\\\":1501,\" + \"\\\"metric\\\":\\\"qryDslamState ERROR\\\",\\\"tags\\\":&#123;\\\"level.keyword\\\":\\\"ERROR\\\",\\\"name\" + \".keyword\\\":\\\"qryDslamState\\\"&#125;&#125;,&#123;\\\"value\\\":1501,\\\"metric\\\":\\\"ERROR BALRELATIONHIS\\\",\\\"tags\\\":&#123;\\\"level\" + \".keyword\\\":\\\"ERROR\\\",\\\"name.keyword\\\":\\\"BALRELATIONHIS\\\"&#125;&#125;,&#123;\\\"value\\\":1501,\\\"metric\\\":\\\"INSTANT_FEE_SE \" + \"ERROR\\\",\\\"tags\\\":&#123;\\\"level.keyword\\\":\\\"ERROR\\\",\\\"name.keyword\\\":\\\"INSTANT_FEE_SE\\\"&#125;&#125;,&#123;\\\"value\\\":1501,\" + \"\\\"metric\\\":\\\"PointInfoQry ERROR\\\",\\\"tags\\\":&#123;\\\"level.keyword\\\":\\\"ERROR\\\",\\\"name\" + \".keyword\\\":\\\"PointInfoQry\\\"&#125;&#125;],\\\"message\\\":\\\"5分钟内 ERROR 已超过 1 次\\\",\\\"ruleId\\\":1,\\\"ruleName\\\":\\\"接口 error \" + \"alert\\\",\\\"ruleUrl\\\":\\\"http://localhost/grafana/d/P75lX0jik/jie-kou-metrics?fullscreen\\\\u0026edit\" + \"\\\\u0026tab=alert\\\\u0026panelId=18\\\\u0026orgId=1\\\",\\\"state\\\":\\\"alerting\\\",\\\"title\\\":\\\"[Alerting] 接口 error\" + \" alert\\\"&#125;\"; private static final String SCRIPT = \"JSONArray evalMatches = json.getJSONArray(\\\"evalMatches\\\");\" + \" StringBuilder sb = new StringBuilder(16);\" + \" String sp = \\\"\\\";\" + \" for (int i = 0; i &lt; evalMatches.size(); i++) &#123;\" + \" JSONObject jsonObject = evalMatches.getJSONObject(i);\" + \" String metric = jsonObject.getString(\\\"metric\\\");\" + \" String value = jsonObject.getString(\\\"value\\\");\" + \" sb.append(sp).append(\\\"指标：\\\").append(metric).append(\\\", 值：\\\").append(value);\" + \" sp = \\\"\\\\n\\\";\" + \" &#125;\" + \" return sb.toString();\"; private final static List&lt;String&gt; DEFAULT_PARAM_NAME_LIST = new ArrayList&lt;&gt;(); private final static List&lt;Class&gt; DEFAULT_PARAM_TYPE_LIST = new ArrayList&lt;&gt;(); static &#123; DEFAULT_PARAM_NAME_LIST.add(\"json\"); DEFAULT_PARAM_TYPE_LIST.add(JSONObject.class); &#125; @Test public void janino() throws CompileException, InvocationTargetException &#123; JSONObject json = JSON.parseObject(JSON_STR); // JSONArray evalMatches = json.getJSONArray(\"evalMatches\"); // StringBuilder sb = new StringBuilder(16); // String sp = \"\"; // for (int i = 0; i &lt; evalMatches.size(); i++) &#123; // JSONObject jsonObject = evalMatches.getJSONObject(i); // String metric = jsonObject.getString(\"metric\"); // String value = jsonObject.getString(\"value\"); // sb.append(sp).append(\"指标：\").append(metric).append(\", 值：\").append(value); // sp = \"&amp;#x000A;\"; // &#125; // return sb.toString(); // import com.alibaba.fastjson.JSON; // import com.alibaba.fastjson.JSONArray; // import com.alibaba.fastjson.JSONObject; // ScriptEvaluator evaluator = new ScriptEvaluator( // \"import com.alibaba.fastjson.JSONArray;\" + // \"import com.alibaba.fastjson.JSONObject;\" + SCRIPT, // String.class, // DEFAULT_PARAM_NAME_LIST.toArray(new String[]&#123;&#125;), // DEFAULT_PARAM_TYPE_LIST.toArray(new Class[]&#123;&#125;) // ); ScriptEvaluator evaluator = new ScriptEvaluator(); // 参数列表、参数类型 evaluator.setParameters(DEFAULT_PARAM_NAME_LIST.toArray(new String[]&#123;&#125;), DEFAULT_PARAM_TYPE_LIST.toArray(new Class[]&#123;&#125;)); // 返回类型 evaluator.setReturnType(String.class); // 脚本、需要导包 evaluator.cook(\"import com.alibaba.fastjson.JSONArray;import com.alibaba.fastjson.JSONObject;\" + SCRIPT); // 执行脚本 Object evaluate = evaluator.evaluate(new Object[]&#123;json&#125;); System.out.println(evaluate); &#125; &#125; 输出 指标：billItemQry ERROR, 值：1501 指标：EXTHIRDQRY ERROR, 值：1501 指标：qryIsOnWay ERROR, 值：1501 指标：autoTestWXKFNew ERROR, 值：1501 指标：checkLineQuality ERROR, 值：1501 指标：ERROR checkRateStateNew, 值：1501 指标：qryDslamState ERROR, 值：1501 指标：ERROR BALRELATIONHIS, 值：1501 指标：INSTANT_FEE_SE ERROR, 值：1501 指标：PointInfoQry ERROR, 值：1501","permalink":"https://blog.dclog.cn/ee85ef5b.html","photos":[]},{"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://blog.dclog.cn/tags/SpringBoot/"},{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://blog.dclog.cn/tags/SpringMVC/"}],"title":"SpringBoot异常处理汇总","date":"2019/04/23","text":"#前言在实际开发中，我们会遇到很多异常，在发生异常的时候Spring Boot默认提供了错误页面展示给用户。看似比较友好，其实页面很丑。上面讲的是做页面开发的时候遇到的问题，还有一种情况就是用来开发Rest接口，当错误的时候我们希望返回给用户的是我们接口的标准格式，不是返回一段html代码。接下来分别给大家介绍下解决方案： #页面处理 首先我们来看页面错误的处理情况，当我们的程序内部报错的时候或者访问的页面找不到的时候，我们可以看到下面的错误页面： #先查看SpringBoot官方文档 大致意思就是Spring Boot本身是内置了一个异常处理机制的, 会判断请求头的参数来区分要返回 JSON 数据还是错误页面. 源码为: org.springframework.boot.autoconfigure.web.servlet.error.BasicErrorController, 他会处理/error 请求. 核心处理代码如下: @RequestMapping( produces = &#123;\"text/html\"&#125; ) // 请求头是text/html则找到错误页面并返回 public ModelAndView errorHtml(HttpServletRequest request, HttpServletResponse response) &#123; // 1.获取Http状态码 HttpStatus status = this.getStatus(request); // 2.调用getErrorAttributes获取响应的map集合 Map&lt;String, Object&gt; model = Collections.unmodifiableMap(this.getErrorAttributes(request, this.isIncludeStackTrace(request, MediaType.TEXT_HTML))); // 3.设置响应头的状态码 response.setStatus(status.value()); // 4. 获取错误页面的路径 ModelAndView modelAndView = this.resolveErrorView(request, response, status, model); // 5. 没有获取到资源则返回默认error页面 return modelAndView != null ? modelAndView : new ModelAndView(\"error\", model); &#125; @RequestMapping @ResponseBody public ResponseEntity&lt;Map&lt;String, Object&gt;&gt; error(HttpServletRequest request) &#123; // 调用 getErrorAttributes 获取响应的 map 结果集. Map&lt;String, Object&gt; body = this.getErrorAttributes(request, this.isIncludeStackTrace(request, MediaType.ALL)); // 获取 HTTP 错误状态码 HttpStatus status = this.getStatus(request); // 返回给页面 JSON 信息. return new ResponseEntity(body, status); &#125; 这两个方法的共同点是: 他们都调用了 this.getErrorAttributes(…) 方法来获取响应信息. 然后来看看他默认情况下对于 AJAX 请求和 HTML 请求, 分别的返回结果是怎样的:对于返回错误页面, 其中还调用了一个非常重要的方法: this.resolveErrorView(request, response, status, model) 方法,分析核心代码 @Override public ModelAndView resolveErrorView(HttpServletRequest request, HttpStatus status, Map&lt;String, Object&gt; model) &#123; // 通过 HTTP 错误状态码获取ModelAndView ModelAndView modelAndView = resolve(String.valueOf(status.value()), model); // 如果没有获取到，并且状态码包含SERIES_VIEWS键名中（SERIES_VIEWS -&gt; HttpStatus内部的枚举Series的Map） if (modelAndView == null &amp;&amp; SERIES_VIEWS.containsKey(status.series())) &#123; // 通过key =&gt; status.series() 的值（4xx,5xx）获取视图 modelAndView = resolve(SERIES_VIEWS.get(status.series()), model); &#125; return modelAndView; &#125; private ModelAndView resolve(String viewName, Map&lt;String, Object&gt; model) &#123; // 加上 error/ 路径 String errorViewName = \"error/\" + viewName; // 先通过模板引擎获取视图 // 遍历所有Sprng容器中 TemplateAvailabilityProvider 的实现类（JspTemplateAvailabilityProvider，TemplateAvailabilityProvider。。。）一个一个获取 // 例如是使用JSP模板， 配置如:spring.mvc.view.prefix=/WEB-INF/page/ spring.mvc.view.suffix=.jsp // 查找路径 classpath:/WEB-INF/page/404.jsp 。。。 TemplateAvailabilityProvider provider = this.templateAvailabilityProviders .getProvider(errorViewName, this.applicationContext); if (provider != null) &#123; return new ModelAndView(errorViewName, model); &#125; // 通过SpringBoot的默认资源获取视图 return resolveResource(errorViewName, model); &#125; private ModelAndView resolveResource(String viewName, Map&lt;String, Object&gt; model) &#123; // \"classpath:/META-INF/resources/\" -&gt; \"classpath:/resources/\" -&gt; \"classpath:/static/\" -&gt; \"classpath:/public/ // 如果配置了 spring.resources.static-locations=/aaa,/bbb 则使用自己配置的 for (String location : this.resourceProperties.getStaticLocations()) &#123; try &#123; Resource resource = this.applicationContext.getResource(location); // 例如 classpath:/META-INF/resources/404.html resource = resource.createRelative(viewName + \".html\"); if (resource.exists()) &#123; return new ModelAndView(new HtmlResourceView(resource), model); &#125; &#125; catch (Exception ex) &#123; &#125; &#125; return null; &#125; 总结：它的作用就是根据 HTTP 状态码来去找错误页面, 如 500 错误会去找 /error/500.html, 403 错误回去找 /error/403.html, 如果找不到则再找 /error/4xx.html 或 /error/5xx.html 页面. 还找不到的话, 如果都没有配置, 则会使用 Spring Boot 默认的页面. 即:这样就可以通过在资源目录下增加404.html、500.html、5xx.html。。。等来达到自定义错误页面的效果 #REST接口处理在开发rest接口时，我们往往会定义统一的返回格式，列如： &#123; \"errcode\": \"0\", \"errmsg\": \"ok\", \"data\": &#123; \"city_name\": \"深圳\", \"area_code\": \"0755\", \"servicer\": \"CTCC\", \"province_name\": \"广东\" &#125; &#125; 但是如果调用方请求我们的api时把接口地址写错了，浏览器请求就会得到一个404错误页面，ajax请求会返回默认格式json数据，最友好的方式就是返回固定的JSON格式 &#123; \"timestamp\": \"2019-04-22T14:48:37.416+0000\", \"status\": 404, \"error\": \"Not Found\", \"message\": \"No message available\", \"path\": \"/rest/test11\" &#125; 可以使用 @ControllerAdvice注解自定义要为特定控制器或异常类型返回的JSON文档 定义返回JSON数据实体类@Data public class BaseResponse implements Serializable &#123; private static final long serialVersionUID = 1L; /** * 状态码：0-成功，其他-失败 */ public String errcode = \"0\"; /** * 成功返回：ok，失败返回具体原因 */ public String errmsg = \"ok\"; /** * 返回的数据结果集 */ public Object data; public BaseResponse() &#123; &#125; .... &#125; 创建自定义Controller异常捕获类@ControllerAdvice public class GlobalExceptionHandler &#123; //捕获指定异常 @ExceptionHandler(ArithmeticException.class) @ResponseBody public BaseResponse arithmeticExceptionHandler(ArithmeticException e)&#123; BaseResponse response = new BaseResponse(); response.setErrmsg(\"ArithmeticException\"); response.setErrcode(\"-1\"); return response; &#125; //捕获其他异常 @ResponseBody @ExceptionHandler(Exception.class) public BaseResponse exceptionHandler(Exception e)&#123; BaseResponse response = new BaseResponse(); response.setErrmsg(\"其他异常\"); response.setErrcode(\"-1\"); return response; &#125; &#125; 使用 @ControllerAdvice + @ExceptionHandler 会发现能够捕获到Controller中抛出的异常，但是没有找到对应的handler是无法捕获到,仍然是走的BasicErrorController的errorHtml或者error方法。下面来分析SpringBoot中异常的分类 #异常的分类在一个Spring Boot项目中，我们可以把异常分为两种，第一种是请求到达Controller层之前，第二种是到达Controller层之后项目代码中发生的错误。而第一种又可以分为两种错误类型：1. 路径错误 2. 类似于请求方式错误，参数类型不对等类似错误。@ExceptionHandler只捕获到第二种异常，如果想要拦截404错误的话,需要在spring boot中做如下设置 spring.mvc.throw-exception-if-no-handler-found=true spring.resources.add-mappings=false 这两行配置的主要意思是告诉spring,如果你请求的地址,没有找到对应的handler,则抛出异常,默认配置是fase,同时也要关掉静态资源的映射,不然并不会起作用. // 捕获404异常 @ExceptionHandler(NoHandlerFoundException.class) @ResponseBody public BaseResponse noHandlerFoundException(NoHandlerFoundException e)&#123; BaseResponse response = new BaseResponse(); response.setErrmsg(\"NoHandlerFoundException\"); response.setErrcode(\"-1\"); return response; &#125; 按照以上的配置,我们可以轻易的将404错误也变成一个异常,然后走统一的异常处理方式,但是这样做是有代价的,就是也会关闭掉spring boot的默认资源mapping功能.(大家可查阅spring boot官方文档,来了解如何处理静态资源)测试时又发现了一个问题,页面请求404会被捕获并返回自定义处理的结果，只能是页面或者json数据，这种方式适用于前端分离的项目。如果项目中有html页面请求做统一处理，又需要对ajax请求返回固定的JSON格式数据这种方式就无法满足了我将这种需求分成两种情况 A.两种Controller分别处理html页面请求和处理ajax请求 B.在一个Controller中有处理html页面请求和处理ajax请求的Mapping(应该很少吧。) #A情况解决方案这种种情况的解决可以使用注解的方式解决，通过注解的方式实现处理异常主要有以下两种方式： 1 @ControllerAdvice+@ExceptionHandler：配置对全局异常进行处理（ControllerAdvice还有很多配置这里就不讲了） 2 @Controller + @ExceptionHandler：配置对当前所在Controller的异常进行处理 @ExceptionHandler：此注解注解到类的方法上，当此注解里定义的异常抛出时，此方法会被执行。如果@ExceptionHandler所在的类是@Controller，则此方法只作用在此类。如果@ExceptionHandler所在的类是@ControllerAdvice，则此方法会作用在全局。全局前面有演示 @RestController @RequestMapping(\"/emp\") public class EmployeeExController &#123; @GetMapping(\"/&#123;id&#125;\") public BaseResponse getEmployee(@PathVariable(\"id\") int id) throws Exception &#123; int i = 1 / 0; return new BaseResponse(); &#125; /** * 此方法只处理本类抛出的 ArithmeticException 异常 */ @ExceptionHandler(ArithmeticException.class) public BaseResponse handleEmployeeNotFoundException(Exception e) &#123; return new BaseResponse(\"-1\", e.getMessage(),\"类级别异常处理\"); &#125; &#125; ####测试执行URL:http://127.0.0.1:8080/emp/1 输出 &#123; \"errcode\": \"-1\", \"errmsg\": \"/ by zero\", \"data\": \"类级别异常处理\" &#125; 并且类级别异常处理要优先与全局处理.这样我们写两个基类。分别进行异常统一处理 public class BaseController &#123; /** * 统一异常处理 */ @ExceptionHandler(value = &#123;Exception.class&#125;) public String exceptionHandler(Exception e) &#123; return \"/error\"; &#125; &#125; public class BaseRestController &#123; /** * 统一异常处理 */ @ExceptionHandler(value = &#123;Exception.class&#125;) public BaseResponse exceptionHandler(Exception e) &#123; return new BaseResponse(-1, e.getMessage(), \"BaseRestController\"); &#125; &#125; 注意：父类处理过的异常子类不能再处理，不然会报错 #B情况解决方案上面有介绍在spring中,专门处理error的类是BasicErrorController,这个类的两个核心方法,一个方法处理html请求的返回,会默认返回一个错误页面另外一个则是处理json请求的,会返回json格式的错误信息,我们看到的默认输出结果,就是这个方法生成的我们现在知道了我们要关注的地方,但是我们如何改造它呢? 细心的spring早就想到了可能存在的客制化需求,所以已经为我们留好了口子. 在源文件里ErrorMvcAutoConfiguration是用来配置BasicErrorController的,如下是核心方法, 这个方法上面标记了@ConditionalOnMissingBean,也就是说我们只需要实现一个ErrorController接口,注入到上下文中就可以了 @ConditionalOnMissingBean的意思 : 当上下文中存在某一个bean,则不初始化当前被标记的bean @Bean @ConditionalOnMissingBean(value = ErrorController.class, search = SearchStrategy.CURRENT) public BasicErrorController basicErrorController(ErrorAttributes errorAttributes) &#123; return new BasicErrorController(errorAttributes, this.serverProperties.getError(), this.errorViewResolvers); &#125; #实现B情况解决方案 创建一个类ExceptionErrorController继承至BasicErrorController public class ExceptionErrorController extends BasicErrorController &#123; public ExceptionErrorController(ErrorAttributes errorAttributes, ErrorProperties errorProperties) &#123; super(errorAttributes, errorProperties); &#125; public ExceptionErrorController(ErrorAttributes errorAttributes, ErrorProperties errorProperties, List&lt;ErrorViewResolver&gt; errorViewResolvers) &#123; super(errorAttributes, errorProperties, errorViewResolvers); &#125; @Override public ModelAndView errorHtml(HttpServletRequest request, HttpServletResponse response) &#123; return super.errorHtml(request, response); &#125; // 继承BasicErrorController的方式返回类型就无法改变了。。 @Override public ResponseEntity&lt;Map&lt;String, Object&gt;&gt; error(HttpServletRequest request) &#123; Map&lt;String, Object&gt; body = getErrorAttributes(request, isIncludeStackTrace(request, MediaType.ALL)); HttpStatus status = getStatus(request); Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); if (status == HttpStatus.NOT_FOUND) &#123; //404处理 map.put(\"errcode\",\"404\"); map.put(\"errmsg\",body.get(\"path\").toString() + \" NoFound\"); &#125; else &#123; //非404处理 Object object = request.getAttribute(\"javax.servlet.error.exception\"); if (object instanceof Exception) &#123; //上下文中能拿到异常的情况 Exception exception = (Exception) object; map.put(\"errcode\",\"-1\"); map.put(\"errmsg\",exception.getMessage()); &#125; else &#123; //上下文中拿不到异常的情况 map.put(\"errcode\",\"-1\"); map.put(\"errmsg\",\"unknow exception\"); &#125; &#125; return new ResponseEntity&lt;&gt;(map,status); &#125; &#125; @Configuration @ConditionalOnWebApplication @ConditionalOnClass(&#123;Servlet.class, DispatcherServlet.class&#125;) @AutoConfigureBefore(WebMvcAutoConfiguration.class) @EnableConfigurationProperties(ResourceProperties.class) public class ExceptionErrorControllerConfig &#123; /** * errorViewResolvers */ @Autowired(required = false) private List&lt;ErrorViewResolver&gt; errorViewResolvers; /** * serverProperties */ @Autowired(required = false) private ServerProperties serverProperties; @Bean public ExceptionErrorController exceptionController(ErrorAttributes errorAttributes)&#123; return new ExceptionErrorController(errorAttributes, this.serverProperties.getError(), this.errorViewResolvers); &#125; &#125; 创建一个类ExceptionController继承至AbstractErrorController(此基类实现了ErrorController)编写如下两个方法,其实就是跟默认实现的方法一样,只是内容可以定制然后类中其他的方法,就按照默认的实现照抄就行了 @Controller @RequestMapping(\"$&#123;server.error.path:$&#123;error.path:/error&#125;&#125;\") public class ExceptionController extends AbstractErrorController &#123; private final ErrorProperties errorProperties; public ExceptionController(ErrorAttributes errorAttributes, ErrorProperties errorProperties) &#123; this(errorAttributes, errorProperties, Collections.emptyList()); &#125; public ExceptionController(ErrorAttributes errorAttributes, ErrorProperties errorProperties, List&lt;ErrorViewResolver&gt; errorViewResolvers) &#123; super(errorAttributes, errorViewResolvers); Assert.notNull(errorProperties, \"ErrorProperties must not be null\"); this.errorProperties = errorProperties; &#125; @Override public String getErrorPath() &#123; return this.errorProperties.getPath(); &#125; @RequestMapping(produces = \"text/html\") public ModelAndView errorHtml(HttpServletRequest request, HttpServletResponse response) &#123; HttpStatus status = getStatus(request); Map&lt;String, Object&gt; model = Collections.unmodifiableMap(getErrorAttributes( request, isIncludeStackTrace(request, MediaType.TEXT_HTML))); response.setStatus(status.value()); ModelAndView modelAndView = resolveErrorView(request, response, status, model); return (modelAndView != null) ? modelAndView : new ModelAndView(\"error\", model); &#125; @RequestMapping @ResponseBody public ResponseEntity&lt;BaseResponse&gt; error(HttpServletRequest request) &#123; Map&lt;String, Object&gt; body = getErrorAttributes(request, isIncludeStackTrace(request, MediaType.ALL)); HttpStatus status = getStatus(request); BaseResponse response = new BaseResponse(); if (status == HttpStatus.NOT_FOUND) &#123; //404处理 response.setErrcode(\"404\"); response.setErrmsg(body.get(\"path\").toString() + \" NoFound\"); &#125; else &#123; //非404处理 Object object = request.getAttribute(\"javax.servlet.error.exception\"); if (object instanceof Exception) &#123; //上下文中能拿到异常的情况 Exception exception = (Exception) object; response.setErrcode(\"-1\"); response.setErrmsg(exception.getMessage()); &#125; else &#123; //上下文中拿不到异常的情况 response.setErrcode(\"-1\"); response.setErrmsg(\"unknow exception\"); &#125; &#125; return new ResponseEntity&lt;&gt;(response, status); &#125; protected boolean isIncludeStackTrace(HttpServletRequest request, MediaType produces) &#123; ErrorProperties.IncludeStacktrace include = getErrorProperties().getIncludeStacktrace(); if (include == ErrorProperties.IncludeStacktrace.ALWAYS) &#123; return true; &#125; if (include == ErrorProperties.IncludeStacktrace.ON_TRACE_PARAM) &#123; return getTraceParameter(request); &#125; return false; &#125; protected ErrorProperties getErrorProperties() &#123; return this.errorProperties; &#125; &#125; @Configuration @ConditionalOnWebApplication @ConditionalOnClass(&#123;Servlet.class, DispatcherServlet.class&#125;) @AutoConfigureBefore(WebMvcAutoConfiguration.class) @EnableConfigurationProperties(ResourceProperties.class) public class ExceptionControllerConfig &#123; /** * errorViewResolvers */ @Autowired(required = false) private List&lt;ErrorViewResolver&gt; errorViewResolvers; /** * serverProperties */ @Autowired(required = false) private ServerProperties serverProperties; @Bean public ExceptionController exceptionController(ErrorAttributes errorAttributes)&#123; return new ExceptionController(errorAttributes, this.serverProperties.getError(), this.errorViewResolvers); &#125; &#125;","permalink":"https://blog.dclog.cn/a22d7ed.html","photos":[]},{"tags":[{"name":"python","slug":"python","permalink":"https://blog.dclog.cn/tags/python/"}],"title":"virtualenv及virtualenvwrapper安装与使用","date":"2019/03/17","text":"#虚拟环境 由于在 使用pip install xxx的时候，这些工具都会安装到默认的位置。 而在平常在切换不同的项目的版本，比如Django1.x和Django2.0之间项目的切换，如果都用同一个开发环境，可能会造成冲突。所以需要一个虚拟环境开隔开这些项目。 #virtualenv 用来建立一个虚拟的python环境，一个专属于项目的python环境。用virtualenv 来保持一个干净的环境非常有用 安装virtualenv pip install virtualenv # 使用豆瓣源 pip install -i https://pypi.doubanio.com/simple/ virtualenv 创建虚拟环境# 使用默认python版本创建 virtualenv py3-test # 指定版本创建 virtualenv -p C:\\Python27\\python.exe py2-test 使用虚拟环境# win py3-test\\Scripts\\activate.bat # liunx #virtualenvwrapper 用于管理虚拟环境。创建和激活的时候不需要切换到具体的目录下操作。 #安装virtualenvwrapper# linux/unix pip install -i https://pypi.doubanio.com/simple/ virtualenvwrapper # win pip install -i https://pypi.doubanio.com/simple/ virtualenvwrapper-win #更改创建路径 默认创建在c盘的文档目录下，可以设置环境变量，改变出虚拟环境创建的路径 新建一个用户环境变量，变量名为 WORKON_HOME 值是你想要存放虚拟环境的路径 变量名(N): WORKON_HOME 变量值(V): D:\\python\\venv #创建虚拟环境mkvirtualenv env-test #切换到某个虚拟环境workon env-test #退出当前虚拟环境deactivate #删除某个虚拟环境rmvirtualenv env-test #列出所有虚拟环境lsvirtualenv workon #切换到虚拟环境的目录cdvirtualenv #创建虚拟环境的时候指定python版本mkvirtualenv --python==C:\\Python27\\python.exe env-test","permalink":"https://blog.dclog.cn/c7b970e7.html","photos":[]},{"tags":[{"name":"nacos alibaba spring-boot","slug":"nacos-alibaba-spring-boot","permalink":"https://blog.dclog.cn/tags/nacos-alibaba-spring-boot/"}],"title":"nacos--配置中心使用","date":"2018/12/24","text":"#什么是nacos Nacos 支持基于 DNS 和基于 RPC 的服务发现（可以作为springcloud的注册中心）、动态配置服务（可以做配置中心）、动态 DNS 服务。 以下内容都是基于spring-boot 2.0.6.RELEASE + nacos #依赖管理项目: nacos-spring-boot-project &lt;dependency&gt; &lt;groupId&gt;com.alibaba.boot&lt;/groupId&gt; &lt;artifactId&gt;nacos-config-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;0.2.1&lt;/version&gt; &lt;/dependency&gt; #基于yml配置nacos: config: server-addr: 192.168.190.128:8848 namespace是命名空间 ID，不能配置命名空间名称。如果不配置namespace，默认使用public #Nacos控制台新建配置Data ID: nacos.cfg.dataIdGroup: test test=dc #启动类@SpringBootApplication @NacosPropertySource(dataId = DATA_ID,groupId = GROUP_ID, autoRefreshed = true) @Slf4j @RestController public class NacosApp &#123; static final String DATA_ID = \"nacos.cfg.dataId\"; static final String GROUP_ID = \"test\"; public static void main(String[] args) &#123; SpringApplication.run(NacosApp.class, args); &#125; @GetMapping(\"/getValue\") public String getValue()&#123; return value; &#125; @GetMapping(\"/getNacosValue\") public String getNacosValue()&#123; return nacosValue; &#125; @Value(value = \"$&#123;test:value&#125;\") private String value; @NacosValue(value = \"$&#123;test:nacosValue&#125;\", autoRefreshed = true) private String nacosValue; @NacosConfigListener( dataId = NacosApp.DATA_ID, timeout = 500 ) public void onChange(String newContent) throws Exception &#123; log.info(\"onChange: &#123;&#125;\", newContent); &#125; &#125; #Spring @Value注解和 Nacos @NacosValue 注解 注解 是否支持动态更新 补充 @Value 否 @NacosValue 是 需配置autoRefreshed=true #测试curl -X GET \"http://192.168.123.59:8080/getValue\" dc curl -X GET \"http://192.168.123.59:8080/getNacosValue\" dc #发布/更改配置 curl -X POST \"http://127.0.0.1:8848/nacos/v1/cs/configs?dataId=nacos.cfg.dataId&amp;group=test&amp;content=test=dcUpdate\" curl -X GET \"http://192.168.123.59:8080/getValue\" dc curl -X GET \"http://192.168.123.59:8080/getNacosValue\" dcUpdate","permalink":"https://blog.dclog.cn/c3aa8a2d.html","photos":[]}]}